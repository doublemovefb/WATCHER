<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>DoubleMove Film Room</title>
  <style>
    :root{
      --bg:#0f1115;--panel:#141824;--muted:#1b2030;--text:#e7eaf3;--accent:#6ea8fe;--accent-2:#9ee493;
      --danger:#ff6b6b;--warn:#ffd166;--shadow:rgba(0,0,0,.35)
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;background:linear-gradient(180deg,#0d0f14 0%,#0b0d12 100%);color:var(--text);font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Inter,Helvetica,Arial,sans-serif}
    .app{display:grid;grid-template-rows:auto 1fr auto;min-height:100vh;}
    header{display:flex;align-items:center;gap:.75rem;padding:.75rem 1rem;background:rgba(20,24,36,.8);backdrop-filter:saturate(1.2) blur(8px);border-bottom:1px solid #222638;position:sticky;top:0;z-index:10}
    header h1{font-size:16px;margin:0 6px 0 0;font-weight:700;letter-spacing:.2px;white-space:nowrap}
    header .controls{display:flex;flex-wrap:wrap;gap:.5rem;align-items:center}
    .btn{appearance:none;border:1px solid #2a3148;background:linear-gradient(180deg,#1a2032,#151a28);color:var(--text);padding:.5rem .7rem;border-radius:10px;cursor:pointer;box-shadow:0 4px 14px var(--shadow);transition:.2s transform,.2s box-shadow,.2s background}
    .btn:hover{transform:translateY(-1px);box-shadow:0 8px 24px var(--shadow)}
    .btn:active{transform:translateY(0)}
    .btn.primary{border-color:#3556a8;background:linear-gradient(180deg,#274078,#1d2f59)}
    .btn.warn{border-color:#66521f;background:linear-gradient(180deg,#4c3c14,#3a2e0f)}
    .btn.danger{border-color:#5e1e1e;background:linear-gradient(180deg,#4b1717,#3b1212)}
    .seg{height:32px;width:1px;background:#2a3148;margin:0 .25rem}
    .toolbar{display:flex;align-items:center;gap:.4rem;background:rgba(20,24,36,.7);border:1px solid #232941;padding:.5rem;border-radius:12px}
    .tool{display:flex;align-items:center;gap:.4rem}
    .tool-icon{display:inline-flex;align-items:center;gap:.35rem}
    .row{display:flex;align-items:center;gap:.5rem}
    .label{opacity:.8;font-size:12px}
    input[type="range"]{accent-color:var(--accent)}
    input[type="color"]{width:32px;height:32px;border:none;border-radius:8px;background:transparent}
    .pill{padding:.25rem .5rem;border:1px solid #2a3148;border-radius:999px;background:#121729;font-size:12px;cursor:pointer}

    main{display:grid;grid-template-columns:280px 1fr;gap:12px;padding:12px}
    aside{background:rgba(20,24,36,.6);border:1px solid #232941;border-radius:16px;padding:10px;display:flex;flex-direction:column;gap:10px}
    .panel{background:linear-gradient(180deg,#131827,#0f1421);border:1px solid #232941;border-radius:14px;padding:10px}
    .panel h3{margin:.2rem 0 .6rem;font-size:13px;opacity:.9}
    .upload{border:1px dashed #2a3148;border-radius:12px;padding:12px;text-align:center}
    .upload input{display:none}
    .upload label{display:block;padding:10px;border-radius:10px;background:#151a25;cursor:pointer;border:1px solid #2a3148}
    .small{font-size:12px;opacity:.8}

    .stage-wrap{position:relative;background:#000;border:1px solid #232941;border-radius:16px;overflow:hidden;min-height:360px;display:grid}
    .stage{place-self:center;position:relative;max-width:100%;max-height:78vh}
    video,canvas{display:block;max-width:100%;height:auto;border-radius:8px}
    canvas.overlay{position:absolute;left:0;top:0;cursor:crosshair}
    canvas.cursor{position:absolute;left:0;top:0;pointer-events:none}
    .badge{font-size:11px;padding:.2rem .4rem;border-radius:6px;border:1px solid #2a3148;background:#121729;opacity:.9}

    footer{display:flex;justify-content:space-between;align-items:center;padding:.5rem 1rem;background:rgba(20,24,36,.8);border-top:1px solid #222638}
    kbd{background:#0e1322;border:1px solid #232941;border-bottom-width:2px;border-radius:6px;padding:.1rem .35rem;font-size:11px}
    .hint{opacity:.8}
    .hidden{display:none}

    @media (max-width: 980px){
      main{grid-template-columns:1fr}
      aside{order:2}
.stage{position:relative;width:100%;height:72vh;max-width:100%}
.overlay{z-index:10}
.cursor{z-index:11}

  body.isFS header{
  position:fixed;left:0;right:0;bottom:0;top:auto;
  border-top:1px solid #222638;border-bottom:none;
  background:rgba(20,24,36,.95);z-index:50
}
body.isFS main{grid-template-columns:1fr;padding:0}
body.isFS aside{display:none}
body.isFS .stage-wrap{height:100vh;border-radius:0}
body.isFS .stage{height:100vh}
body.isFS footer{display:none}

    }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <h1>üèà NFL Film Telestrator</h1>
      <div class="controls">
        <button id="openBtn" class="btn primary">Import Video</button>
        <input id="fileInput" type="file" accept="video/*" class="hidden" />
        <button id="playBtn" class="btn">Play</button>
        <div class="row"><span class="label">Speed</span><input id="speed" type="range" min="0.25" max="2" step="0.25" value="1"/></div>
        <div class="row" id="speedPresets">
          <span class="label">Presets</span>
          <button class="btn pill" data-setspeed="0.5">0.5√ó</button>
          <button class="btn pill" data-setspeed="1">1.0√ó</button>
          <button class="btn pill" data-setspeed="1.2">1.2√ó</button>
          <button class="btn pill" data-setspeed="1.5">1.5√ó</button>
          <button class="btn pill" data-setspeed="2">2.0√ó</button>
        </div>
        <div class="row"><span class="label">Jump</span><button class="btn" data-skip="-5000">-5s</button><button class="btn" data-skip="5000">+5s</button></div>
        <div class="seg"></div>
        <div class="toolbar">
          <div class="tool tool-icon">
            <span class="label">Tool</span>
            <select id="tool">
              <option value="pen">üñäÔ∏è Pen</option>
              <option value="line">Ôºè Line</option>
              <option value="arrow">‚û§ Arrow</option>
              <option value="rect">‚ñ≠ Rectangle</option>
              <option value="circle">‚óØ Circle</option>
              <option value="text">T Text</option>
              <option value="erase">‚úï Eraser</option>
              <option value="preset">üèà Route Preset</option>
            </select>
          </div>
          <div class="tool">
            <span class="label">Color</span>
            <input id="color" type="color" value="#ffcc00" />
          </div>
          <div class="tool">
            <span class="label">Size</span>
            <input id="size" type="range" min="2" max="20" step="1" value="6" />
          </div>
          <div class="tool" id="presetControls" style="display:none;gap:.35rem">
            <span class="label">Route</span>
            <select id="preset">
              <option value="slant">Slant</option>
              <option value="out">Out</option>
              <option value="in">In (Dig)</option>
              <option value="curl">Curl</option>
              <option value="hitch">Hitch</option>
              <option value="post">Post</option>
              <option value="corner">Corner</option>
              <option value="go">Go (Fade)</option>
              <option value="drag">Drag</option>
              <option value="cross">Cross</option>
              <option value="wheel">Wheel</option>
            </select>
            <span class="label">Face</span>
            <select id="presetDir">
              <option value="right">Right ‚ñ∂</option>
              <option value="left">‚óÄ Left</option>
            </select>
            <span class="label">Scale</span>
            <input id="presetScale" type="range" min="0.5" max="2" step="0.1" value="1" />
          </div>
          <button id="undoBtn" class="btn" title="Undo (Z)">Undo</button>
          <button id="redoBtn" class="btn" title="Redo (Y)">Redo</button>
          <button id="toggleAnnoBtn" class="btn" title="Hide/Show (H)">Hide</button>
          <button id="clearBtn" class="btn warn" title="Clear annotations">Clear</button>
        </div>
        <div class="seg"></div>
        <button id="snapBtn" class="btn">Save Snapshot</button>
        <button id="recBtn" class="btn">Start Recording</button>
        <a id="dlLink" class="btn hidden" download>Download</a>
      </div>
    </header>

    <main>
      <aside>
        <div class="panel">
          <h3>Import</h3>
          <div class="upload" id="dropZone">
            <p>Drag & drop a video here, or</p>
            <label for="fileInput">Choose File</label>
            <p class="small">MP4/WebM/MOV recommended. File stays local in your browser.</p>
          </div>
        </div>
        <div class="panel">
          <h3>Annotations</h3>
          <div class="row" style="flex-wrap:wrap;gap:.4rem">
            <span class="badge">Space = Play/Pause</span>
            <span class="badge">Z = Undo</span>
            <span class="badge">Y = Redo</span>
            <span class="badge">H = Hide/Show</span>
            <span class="badge">[ / ] = Size</span>
            <span class="badge">+ / ‚àí = Speed</span>
          </div>
        </div>
        <div class="panel">
          <h3>Recording (Beta)</h3>
          <p class="small">Records the video + drawings to WebM. Playback in Chrome/Edge. Long sessions can be large.</p>
        </div>
      </aside>

      <section class="stage-wrap">
        <div class="stage" id="stage">
          <video id="video" crossorigin="anonymous" playsinline></video>
          <canvas id="overlay" class="overlay"></canvas>
          <canvas id="cursor" class="overlay cursor"></canvas>
        </div>
      </section>
    </main>

    <footer>
      <div class="hint">Local-only. Nothing uploads anywhere. Built for solo breakdowns.</div>
      <div>¬© <span id="year"></span> Telestrator</div>
    </footer>
  </div>

  <script>
  // --- Utility
  const $ = sel => document.querySelector(sel);
  const $$ = sel => Array.from(document.querySelectorAll(sel));

  const video = $('#video');
  const overlay = $('#overlay');
  const cursor = $('#cursor');
  const stage = $('#stage');
  const ctx = overlay.getContext('2d');
  const cx = cursor.getContext('2d');
  const fileInput = $('#fileInput');
  const openBtn = $('#openBtn');
  const playBtn = $('#playBtn');
  const speed = $('#speed');
  const toolSel = $('#tool');
  const color = $('#color');
  const size = $('#size');
  const undoBtn = $('#undoBtn');
  const redoBtn = $('#redoBtn');
  const clearBtn = $('#clearBtn');
  const toggleAnnoBtn = $('#toggleAnnoBtn');
  const snapBtn = $('#snapBtn');
  const recBtn = $('#recBtn');
  const dlLink = $('#dlLink');
  const dropZone = $('#dropZone');
  const year = $('#year');
  year.textContent = new Date().getFullYear();

  let drawing = false;
  let hidden = false;
  let currentTool = 'pen';
  let strokes = []; // {tool,color,size,points:[{x,y}],text?,meta?}
  let redoStack = [];
  let lastPos = {x:0,y:0};

  // For recording: composite offscreen canvas
  const composite = document.createElement('canvas');
  const cc = composite.getContext('2d');
  let rafId = null;
  let mediaRecorder = null;
  let recordedChunks = [];

  function fitCanvases(){
    const w = video.videoWidth || 1920;
    const h = video.videoHeight || 1080;

    // Fit within stage
    const stageRect = stage.getBoundingClientRect();
    const scale = Math.min(stageRect.width / w, stageRect.height / h);
    const cw = Math.max(1, Math.floor(w * scale));
    const ch = Math.max(1, Math.floor(h * scale));

    // Size the video via CSS for aspect; canvas must match CSS pixels
    video.style.width = cw + 'px';
    video.style.height = ch + 'px';

    overlay.width = cw; overlay.height = ch;
    overlay.style.width = cw + 'px';
    overlay.style.height = ch + 'px';

    cursor.width = cw; cursor.height = ch;
    cursor.style.width = cw + 'px';
    cursor.style.height = ch + 'px';

    composite.width = cw; composite.height = ch;
  }

  function loadVideoFile(file){
    const url = URL.createObjectURL(file);
    video.src = url;
    video.onloadedmetadata = () => {
      fitCanvases();
      video.currentTime = 0;
      video.pause();
      playBtn.textContent = 'Play';
    };
  }

  // --- Drag & drop
  ;['dragenter','dragover'].forEach(evt=>dropZone.addEventListener(evt,e=>{e.preventDefault();dropZone.style.background='#0f1426'}));
  ;['dragleave','drop'].forEach(evt=>dropZone.addEventListener(evt,e=>{e.preventDefault();dropZone.style.background='' }));
  dropZone.addEventListener('drop', e=>{
    const f = e.dataTransfer.files?.[0];
    if(f && f.type.startsWith('video/')) loadVideoFile(f);
  });

  // --- Controls
  openBtn.onclick = () => fileInput.click();
  fileInput.onchange = (e)=>{
    const f = e.target.files?.[0];
    if(f) loadVideoFile(f);
  };

  playBtn.onclick = ()=>{
    if(video.paused){ video.play(); playBtn.textContent='Pause'; }
    else { video.pause(); playBtn.textContent='Play'; }
  };

  speed.oninput = ()=>{ video.playbackRate = parseFloat(speed.value); };
  $$('#speedPresets [data-setspeed]').forEach(b=>b.onclick=()=>{ const v=parseFloat(b.dataset.setspeed); speed.value=v; video.playbackRate=v; });
  $$('button[data-skip]').forEach(b=>b.onclick=()=>{ video.currentTime += parseFloat(b.dataset.skip)/1000; });

  toolSel.onchange = ()=> { currentTool = toolSel.value; updateToolUI(); drawCursorGlyph(lastPos); };
  toggleAnnoBtn.onclick = ()=>{ hidden=!hidden; overlay.style.opacity = hidden? .1: 1; toggleAnnoBtn.textContent = hidden? 'Show':'Hide'; };
  clearBtn.onclick = ()=>{ if(confirm('Clear all annotations?')){ strokes=[]; redoStack=[]; redraw(); } };
  undoBtn.onclick = undo; redoBtn.onclick = redo;

  // --- Drawing helpers
  function getPos(evt){
    const rect = overlay.getBoundingClientRect();
    let x,y;
    if(evt.touches && evt.touches[0]){ x = evt.touches[0].clientX; y=evt.touches[0].clientY; }
    else { x=evt.clientX; y=evt.clientY; }
    return { x: (x-rect.left), y: (y-rect.top) };
  }

  function startStroke(pt){
    // route preset placement
    if(currentTool==='preset'){
      const path = makeRoutePath($('#preset').value, $('#presetDir').value, parseFloat($('#presetScale').value));
      const translated = path.map(p=>({ x: pt.x + p.x, y: pt.y + p.y }));
      const stroke = { tool:'pen', color: color.value, size: parseInt(size.value,10), points: translated, meta:{preset:$('#preset').value} };
      strokes.push(stroke); redoStack.length=0; redraw(); return;
    }
    const stroke = { tool: currentTool, color: color.value, size: parseInt(size.value,10), points: [pt] };
    if(currentTool==='text'){
      const text = prompt('Enter text label:');
      if(!text) return;
      stroke.text = text; stroke.points=[pt];
      strokes.push(stroke); redoStack.length=0; redraw(); return;
    }
    strokes.push(stroke); redoStack.length=0;
  }

  function addPoint(pt){
    const s = strokes[strokes.length-1]; if(!s) return;
    if(['line','arrow','rect','circle'].includes(s.tool)){
      s.points[1]=pt; // dynamic endpoint
    } else {
      s.points.push(pt);
    }
    redraw();
  }

  function endStroke(){ drawing=false; drawCursorGlyph(lastPos); }

  function undo(){ if(strokes.length){ redoStack.push(strokes.pop()); redraw(); } }
  function redo(){ if(redoStack.length){ strokes.push(redoStack.pop()); redraw(); } }

  function drawArrow(from,to,size,color){
    const ang = Math.atan2(to.y-from.y, to.x-from.x);
    const headLen = Math.max(10, size*3);
    ctx.strokeStyle=color; ctx.lineWidth=size; ctx.lineCap='round'; ctx.lineJoin='round';
    ctx.beginPath(); ctx.moveTo(from.x,from.y); ctx.lineTo(to.x,to.y); ctx.stroke();
    // head
    ctx.beginPath();
    ctx.moveTo(to.x,to.y);
    ctx.lineTo(to.x - headLen*Math.cos(ang - Math.PI/6), to.y - headLen*Math.sin(ang - Math.PI/6));
    ctx.moveTo(to.x,to.y);
    ctx.lineTo(to.x - headLen*Math.cos(ang + Math.PI/6), to.y - headLen*Math.sin(ang + Math.PI/6));
    ctx.stroke();
  }

  function redraw(){
    ctx.clearRect(0,0,overlay.width,overlay.height);
    for(const s of strokes){
      ctx.strokeStyle = s.tool==='erase' ? 'rgba(0,0,0,0)' : s.color;
      ctx.lineWidth = s.size; ctx.lineCap='round'; ctx.lineJoin='round';
      if(s.tool==='pen' || s.tool==='erase'){
        ctx.globalCompositeOperation = s.tool==='erase' ? 'destination-out' : 'source-over';
        ctx.beginPath();
        s.points.forEach((p,i)=>{ if(i===0) ctx.moveTo(p.x,p.y); else ctx.lineTo(p.x,p.y); });
        ctx.stroke();
        ctx.globalCompositeOperation = 'source-over';
      } else if(s.tool==='line'){
        if(s.points.length<2) continue;
        ctx.beginPath(); ctx.moveTo(s.points[0].x,s.points[0].y); ctx.lineTo(s.points[1].x,s.points[1].y); ctx.stroke();
      } else if(s.tool==='arrow'){
        if(s.points.length<2) continue;
        drawArrow(s.points[0], s.points[1], s.size, s.color);
      } else if(s.tool==='rect'){
        if(s.points.length<2) continue;
        const x=s.points[0].x, y=s.points[0].y, w=s.points[1].x-x, h=s.points[1].y-y;
        ctx.strokeRect(x,y,w,h);
      } else if(s.tool==='circle'){
        if(s.points.length<2) continue;
        const dx=s.points[1].x-s.points[0].x, dy=s.points[1].y-s.points[0].y;
        const r=Math.hypot(dx,dy);
        ctx.beginPath(); ctx.arc(s.points[0].x,s.points[0].y,r,0,Math.PI*2); ctx.stroke();
      } else if(s.tool==='text'){
        ctx.fillStyle=s.color; ctx.font = `bold ${Math.max(14,s.size*4)}px system-ui, -apple-system, Segoe UI, Roboto`; ctx.textBaseline='top';
        ctx.fillText(s.text, s.points[0].x, s.points[0].y);
      }
    }
  }

  // Drawing events
  function pointerDown(e){ e.preventDefault(); drawing=true; const p=getPos(e); startStroke(p); }
  function pointerMove(e){ if(!drawing) return; const p=getPos(e); addPoint(p); }
  function pointerUp(e){ if(!drawing) return; endStroke(); }

  overlay.addEventListener('mousedown', pointerDown);
  window.addEventListener('mousemove', pointerMove);
  window.addEventListener('mouseup', pointerUp);
  overlay.addEventListener('mousemove', e=>{ lastPos=getPos(e); drawCursorGlyph(lastPos); });
  overlay.addEventListener('touchstart', pointerDown, {passive:false});
  window.addEventListener('touchmove', e=>{ if(e.touches&&e.touches[0]) lastPos=getPos(e); if(drawing) pointerMove(e); drawCursorGlyph(lastPos); }, {passive:false});
  window.addEventListener('touchend', pointerUp);

  // Resize handling
  window.addEventListener('resize', ()=>{ const i=video.paused; fitCanvases(); redraw(); drawCursorGlyph(lastPos); if(!i) requestAnimationFrame(()=>{}); });

  // Keyboard shortcuts
  window.addEventListener('keydown', (e)=>{
    if(e.key===' '){ e.preventDefault(); playBtn.click(); }
    else if(e.key.toLowerCase()==='z'){ undo(); }
    else if(e.key.toLowerCase()==='y'){ redo(); }
    else if(e.key.toLowerCase()==='h'){ toggleAnnoBtn.click(); }
    else if(e.key==='['){ size.value = Math.max(2, parseInt(size.value)-1); }
    else if(e.key===']'){ size.value = Math.min(20, parseInt(size.value)+1); }
    else if(e.key==='+'){ speed.value = Math.min(2, parseFloat(speed.value)+0.25); speed.oninput(); }
    else if(e.key==='-'){ speed.value = Math.max(0.25, parseFloat(speed.value)-0.25); speed.oninput(); }
    else if((e.ctrlKey||e.metaKey) && e.key.toLowerCase()==='s'){ e.preventDefault(); saveSnapshot(); }
  });

  // tool UI visibility and cursor glyph
  function updateToolUI(){
    const show = currentTool==='preset';
    $('#presetControls').style.display = show ? 'flex' : 'none';
    overlay.style.cursor = currentTool==='text' ? 'text' : (currentTool==='erase' ? 'not-allowed' : 'crosshair');
  }

  function drawCursorGlyph(pos){
    if(!cursor.width) return;
    cx.clearRect(0,0,cursor.width,cursor.height);
    if(!pos || drawing) return;
    const s = parseInt(size.value,10);
    cx.save();
    cx.translate(pos.x+12, pos.y+12);
    cx.lineWidth = Math.max(1, Math.floor(s/2));
    cx.strokeStyle = color.value; cx.fillStyle = color.value;
    switch(currentTool){
      case 'pen': cx.beginPath(); cx.arc(0,0, s/2, 0, Math.PI*2); cx.stroke(); break;
      case 'erase': cx.globalAlpha=.9; cx.beginPath(); cx.arc(0,0, s/2, 0, Math.PI*2); cx.stroke(); cx.globalAlpha=1; break;
      case 'line': cx.beginPath(); cx.moveTo(-8,-8); cx.lineTo(8,8); cx.stroke(); break;
      case 'arrow': drawMiniArrow(-8,-2, 10, 0); break;
      case 'rect': cx.strokeRect(-8,-8,16,16); break;
      case 'circle': cx.beginPath(); cx.arc(0,0,10,0,Math.PI*2); cx.stroke(); break;
      case 'text': cx.font='bold 16px system-ui'; cx.fillText('T', -5,5); break;
      case 'preset': cx.beginPath(); cx.moveTo(-10,0); cx.quadraticCurveTo(-5,-12,0,0); cx.quadraticCurveTo(5,12,10,0); cx.stroke(); break;
    }
    cx.restore();
  }
  function drawMiniArrow(x,y,len,ang){
    cx.save(); cx.translate(x,y); cx.rotate(ang);
    cx.beginPath(); cx.moveTo(0,0); cx.lineTo(len,0); cx.stroke();
    const head=6; cx.beginPath(); cx.moveTo(len,0); cx.lineTo(len-head, -head/1.6); cx.moveTo(len,0); cx.lineTo(len-head, head/1.6); cx.stroke();
    cx.restore();
  }

  // Snapshot (video + overlay)
  function saveSnapshot(){
    if(!video.src){ alert('Import a video first.'); return; }
    composite.width = overlay.width; composite.height = overlay.height;
    cc.clearRect(0,0,composite.width,composite.height);
    try{ cc.drawImage(video, 0,0, composite.width, composite.height); } catch(err){ console.warn(err); }
    cc.drawImage(overlay, 0,0);
    const url = composite.toDataURL('image/png');
    dlLink.href = url; dlLink.download = `telestrator-snapshot-${Date.now()}.png`;
    dlLink.textContent = 'Download Snapshot';
    dlLink.classList.remove('hidden');
    dlLink.click();
  }
  snapBtn.onclick = saveSnapshot;

  // Recording (composite canvas stream)
  function drawLoop(){
    cc.clearRect(0,0,composite.width,composite.height);
    try{ cc.drawImage(video, 0,0, composite.width, composite.height); } catch(err){}
    cc.drawImage(overlay, 0,0);
    rafId = requestAnimationFrame(drawLoop);
  }

  recBtn.onclick = async ()=>{
    if(mediaRecorder && mediaRecorder.state==='recording'){
      mediaRecorder.stop();
      cancelAnimationFrame(rafId);
      recBtn.textContent='Start Recording';
      playBtn.disabled=false; speed.disabled=false;
      return;
    }
    if(!video.src){ alert('Import a video first.'); return; }
    composite.width = overlay.width; composite.height = overlay.height;
    recordedChunks = [];
    drawLoop();
    const stream = composite.captureStream(30);
    try{
      const audioCtx = new (window.AudioContext||window.webkitAudioContext)();
      const dest = audioCtx.createMediaStreamDestination();
      const src = audioCtx.createMediaElementSource(video);
      src.connect(dest); src.connect(audioCtx.destination);
      dest.stream.getAudioTracks().forEach(t=>stream.addTrack(t));
    }catch(err){ console.warn('Audio capture unavailable:', err); }

    try{ mediaRecorder = new MediaRecorder(stream, { mimeType: 'video/webm;codecs=vp9' }); }
    catch(e){ mediaRecorder = new MediaRecorder(stream); }

    mediaRecorder.ondataavailable = e=>{ if(e.data.size>0) recordedChunks.push(e.data); };
    mediaRecorder.onstop = ()=>{
      const blob = new Blob(recordedChunks, { type: 'video/webm' });
      const url = URL.createObjectURL(blob);
      dlLink.href = url; dlLink.download = `telestrator-${Date.now()}.webm`;
      dlLink.textContent = 'Download Recording';
      dlLink.classList.remove('hidden');
    };
    mediaRecorder.start(200);
    recBtn.textContent='Stop Recording';
    if(video.paused) video.play();
    playBtn.disabled=true; speed.disabled=true;
  };

  // Route preset generator
  function makeRoutePath(name, dir='right', scale=1){
    const step = 60 * scale; // approx yards in px
    const flip = dir==='left' ? -1 : 1;
    const P = [];
    const add=(x,y)=>P.push({x:x*flip, y});
    switch(name){
      case 'slant': add(0,0); add(1*step,-.4*step); add(2*step,-.8*step); break;
      case 'out': add(0,0); add(1.5*step,0); add(1.5*step,-1*step); break;
      case 'in': add(0,0); add(1.5*step,0); add(1.5*step,.6*step); break;
      case 'curl': add(0,0); add(1.8*step,0); add(1.6*step,-.4*step); add(1.4*step,.2*step); break;
      case 'hitch': add(0,0); add(1.2*step,0); add(1.1*step,-.2*step); break;
      case 'post': add(0,0); add(2*step,0); add(3*step,-1.2*step); break;
      case 'corner': add(0,0); add(2*step,0); add(3*step,-.2*step); add(3.6*step,-1.4*step); break;
      case 'go': add(0,0); add(3.5*step,0); break;
      case 'drag': add(0,0); add(1*step,.2*step); add(2*step,.2*step); add(3*step,.2*step); break;
      case 'cross': add(0,0); add(1*step,-.4*step); add(2*step,-.8*step); add(3*step,-.6*step); break;
      case 'wheel': add(0,0); add(1*step,0); add(1.5*step,-.2*step); add(2*step,-.6*step); add(2.1*step,-1.2*step); break;
      default: add(0,0); add(1*step,0);
    }
    return P;
  }

  // Keep overlay in sync with video size
  video.addEventListener('loadedmetadata', fitCanvases);
  video.addEventListener('resize', fitCanvases);

  // Initialize defaults
  fitCanvases();
  updateToolUI();
  video.controls = true; // native controls also
    <script>
// --- Fullscreen helpers (desktop + iOS Safari fallback)
(function(){
  const fsBtn = document.getElementById('fsBtn');
  const wrap = document.querySelector('.stage-wrap');
  const vid  = document.getElementById('video');

  function enterFS(){
    if (wrap.requestFullscreen) return wrap.requestFullscreen();
    // iOS Safari fallback: fullscreen the <video> element
    if (vid && vid.webkitEnterFullscreen) return vid.webkitEnterFullscreen();
  }
  function exitFS(){
    if (document.fullscreenElement && document.exitFullscreen) return document.exitFullscreen();
    // iOS video exits FS with done button; nothing to do.
  }

  if (fsBtn && wrap){
    fsBtn.addEventListener('click', ()=>{
      if (!document.fullscreenElement) enterFS(); else exitFS();
    });

    document.addEventListener('fullscreenchange', ()=>{
      document.body.classList.toggle('isFS', !!document.fullscreenElement);
      // Refit canvases when size changes
      const paused = video.paused;
      if (typeof fitCanvases === 'function') fitCanvases();
      if (typeof redraw === 'function') redraw();
      if (!paused) requestAnimationFrame(()=>{});
    });
  }
})();
</script>
</body>
</html>
